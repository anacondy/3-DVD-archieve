name: Update Repository Status

on:
  schedule:
    # Run at 00:00 UTC on odd days and 08:00 UTC on even days
    # This creates approximately 32-hour intervals
    - cron: '0 0 1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31 * *'  # 00:00 on odd days
    - cron: '0 8 2,4,6,8,10,12,14,16,18,20,22,24,26,28,30 * *'    # 08:00 on even days
  workflow_dispatch: # Allow manual trigger

permissions:
  contents: write

jobs:
  update-status:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          
      - name: Check last update time and skip if too recent
        id: check_time
        run: |
          if [ -f .last_update ]; then
            last_update=$(cat .last_update)
            current_time=$(date +%s)
            time_diff=$((current_time - last_update))
            hours_diff=$((time_diff / 3600))
            
            if [ $hours_diff -lt 30 ]; then
              echo "Last update was $hours_diff hours ago. Skipping..."
              echo "should_run=false" >> $GITHUB_OUTPUT
              exit 0
            fi
          fi
          
          echo "should_run=true" >> $GITHUB_OUTPUT
          date +%s > .last_update
          
      - name: Discover and update repositories
        if: steps.check_time.outputs.should_run == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          node << 'EOF'
          const fs = require('fs');
          const https = require('https');
          
          // Configuration
          const orgName = 'anacondy';
          
          // Function to make GitHub API requests
          function githubApiRequest(path) {
            return new Promise((resolve, reject) => {
              const options = {
                hostname: 'api.github.com',
                path: path,
                method: 'GET',
                headers: {
                  'User-Agent': 'RepoStatusChecker/1.0',
                  'Accept': 'application/vnd.github+json',
                  'Authorization': `Bearer ${process.env.GITHUB_TOKEN}`,
                  'X-GitHub-Api-Version': '2022-11-28'
                }
              };
              
              const req = https.request(options, (res) => {
                let data = '';
                
                res.on('data', (chunk) => {
                  data += chunk;
                });
                
                res.on('end', () => {
                  if (res.statusCode === 200) {
                    try {
                      resolve(JSON.parse(data));
                    } catch (parseError) {
                      reject(new Error(`Failed to parse JSON response: ${parseError.message}`));
                    }
                  } else {
                    reject(new Error(`GitHub API returned status ${res.statusCode}: ${data}`));
                  }
                });
              });
              
              req.on('error', (error) => {
                reject(error);
              });
              
              req.end();
            });
          }
          
          // Function to check if URL is accessible
          function checkUrl(url) {
            return new Promise((resolve) => {
              const options = {
                method: 'HEAD',
                timeout: 10000,
                headers: {
                  'User-Agent': 'Mozilla/5.0 (compatible; RepoStatusChecker/1.0)'
                }
              };
              
              const req = https.request(url, options, (res) => {
                if (res.statusCode === 200) {
                  resolve('active');
                } else if (res.statusCode === 404) {
                  resolve('404');
                } else {
                  // Other status codes might indicate building or temporary issues
                  resolve('building');
                }
              });
              
              req.on('error', () => {
                resolve('404');
              });
              
              req.on('timeout', () => {
                req.destroy();
                resolve('building');
              });
              
              req.end();
            });
          }
          
          // Function to delay between requests
          function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
          }
          
          // Fetch all public repositories from the organization
          async function discoverRepositories() {
            console.log('Discovering repositories from GitHub...');
            const allRepos = [];
            let page = 1;
            
            while (true) {
              const repos = await githubApiRequest(`/orgs/${orgName}/repos?type=public&per_page=100&page=${page}`);
              
              allRepos.push(...repos);
              console.log(`Fetched page ${page}: ${repos.length} repositories`);
              
              if (repos.length < 100) break; // Last page (includes empty pages)
              page++;
              await delay(200); // Rate limiting
            }
            
            console.log(`Total repositories found: ${allRepos.length}`);
            return allRepos;
          }
          
          // Check if repository has GitHub Pages enabled
          async function hasGitHubPages(repoName) {
            try {
              const pages = await githubApiRequest(`/repos/${orgName}/${repoName}/pages`);
              // Accept pages that are built or building
              return pages && (pages.status === 'built' || pages.status === 'building');
            } catch (error) {
              // Only return false for 404 (no GitHub Pages)
              // For other errors (rate limiting, network issues), log and return true to be safe
              if (error.message && error.message.includes('404')) {
                return false;
              }
              console.log(`  Warning: Error checking Pages for ${repoName}: ${error.message}. Assuming has pages.`);
              return true;
            }
          }
          
          // Main update function
          async function updateRepoStatuses() {
            // Discover all repositories
            const allRepos = await discoverRepositories();
            
            // Read current repos.json to preserve existing data
            let existingRepos = {};
            try {
              const existingData = JSON.parse(fs.readFileSync('repos.json', 'utf8'));
              existingData.forEach(repo => {
                existingRepos[repo.name] = repo;
              });
            } catch (error) {
              console.log('No existing repos.json found, starting fresh.');
            }
            
            const reposData = [];
            let newRepos = 0;
            
            console.log('\nChecking repositories for GitHub Pages...');
            
            for (let i = 0; i < allRepos.length; i++) {
              const repo = allRepos[i];
              console.log(`[${i + 1}/${allRepos.length}] Checking ${repo.name}...`);
              
              // Check if GitHub Pages is enabled
              const pagesEnabled = await hasGitHubPages(repo.name);
              await delay(200); // Rate limiting
              
              if (!pagesEnabled) {
                console.log(`  No GitHub Pages enabled, skipping.`);
                continue;
              }
              
              console.log(`  GitHub Pages enabled!`);
              
              const url = `https://${orgName}.github.io/${repo.name}/`;
              
              // Check if repo exists in our current data
              const existingRepo = existingRepos[repo.name];
              
              if (existingRepo) {
                // Check status
                const status = await checkUrl(url);
                console.log(`  Status: ${status}`);
                
                // Determine the date to use
                let repoDate = existingRepo.date;
                if (status === 'active' && existingRepo.status !== 'active') {
                  repoDate = new Date().toISOString().split('T')[0];
                  console.log(`  Date updated!`);
                }
                
                reposData.push({
                  name: repo.name,
                  url: url,
                  date: repoDate,
                  status: status
                });
              } else {
                // New repository discovered
                const status = await checkUrl(url);
                console.log(`  NEW repository! Status: ${status}`);
                
                reposData.push({
                  name: repo.name,
                  url: url,
                  date: new Date().toISOString().split('T')[0],
                  status: status
                });
                newRepos++;
              }
              
              await delay(200); // Rate limiting
            }
            
            console.log(`\nDiscovery complete!`);
            console.log(`Total repositories with GitHub Pages: ${reposData.length}`);
            console.log(`New repositories discovered: ${newRepos}`);
            
            // Sort by date descending (newest first)
            reposData.sort((a, b) => new Date(b.date) - new Date(a.date));
            
            // Write updated data back to file
            fs.writeFileSync('repos.json', JSON.stringify(reposData, null, 2));
            console.log('repos.json updated successfully.');
          }
          
          updateRepoStatuses().catch(error => {
            console.error('Error updating repository statuses:', error);
            process.exit(1);
          });
          EOF
          
      - name: Commit and push if changed
        if: steps.check_time.outputs.should_run == 'true'
        run: |
          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'
          git add repos.json .last_update
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "Auto-update repository status [skip ci]"
            git push
            echo "Changes committed and pushed"
          fi
