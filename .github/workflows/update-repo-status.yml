name: Update Repository Status
on:
  schedule:
    - cron: '0 0 * * *'  # Runs every day at 00:00 UTC
  workflow_dispatch: # Allow manual trigger

permissions:
  contents: write

jobs:
  update-status:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Discover and update repositories
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          node << 'EOF'
          const fs = require('fs');
          const https = require('https');

          // Configuration
          const userName = 'anacondy';

          // Function to make GitHub API requests
          function githubApiRequest(path) {
            return new Promise((resolve, reject) => {
              const options = {
                hostname: 'api.github.com',
                path: path,
                method: 'GET',
                headers: {
                  'User-Agent': 'RepoStatusChecker/1.0',
                  'Accept': 'application/vnd.github+json',
                  'Authorization': `Bearer ${process.env.GITHUB_TOKEN}`,
                  'X-GitHub-Api-Version': '2022-11-28'
                }
              };

              const req = https.request(options, (res) => {
                let data = '';

                res.on('data', (chunk) => {
                  data += chunk;
                });

                res.on('end', () => {
                  if (res.statusCode >= 200 && res.statusCode < 300) {
                    try {
                      resolve(JSON.parse(data));
                    } catch (parseError) {
                      reject(new Error(`Failed to parse JSON response: ${parseError.message}`));
                    }
                  } else {
                    const error = new Error(`GitHub API returned status ${res.statusCode}`);
                    error.statusCode = res.statusCode;
                    error.responseData = data.length > 200 ? data.substring(0, 200) + '...' : data;
                    reject(error);
                  }
                });
              });

              req.on('error', (error) => {
                reject(error);
              });

              req.end();
            });
          }

          // Function to check if URL is accessible
          function checkUrl(url) {
            return new Promise((resolve) => {
              const options = {
                method: 'HEAD',
                timeout: 10000,
                headers: {
                  'User-Agent': 'Mozilla/5.0 (compatible; RepoStatusChecker/1.0)'
                }
              };

              const req = https.request(url, options, (res) => {
                if (res.statusCode === 200) {
                  resolve('active');
                } else if (res.statusCode === 404) {
                  resolve('404');
                } else {
                  resolve('building');
                }
              });

              req.on('error', () => {
                resolve('404');
              });

              req.on('timeout', () => {
                req.destroy();
                resolve('building');
              });

              req.end();
            });
          }

          // Function to delay between requests
          function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
          }

          // Fetch all public repositories from the user
          async function discoverRepositories() {
            console.log('Discovering repositories from GitHub...');
            const allRepos = [];
            let page = 1;
            const maxPages = 50;

            while (page <= maxPages) {
              try {
                const repos = await githubApiRequest(`/users/${userName}/repos?type=public&per_page=100&page=${page}`);

                if (!repos || repos.length === 0) break;

                allRepos.push(...repos);
                console.log(`Fetched page ${page}: ${repos.length} repositories`);

                if (repos.length < 100) break;
                page++;
                await delay(200);
              } catch (error) {
                console.error(`Error fetching repositories on page ${page}:`, error.message);
                break;
              }
            }

            console.log(`Total repositories found: ${allRepos.length}`);
            return allRepos;
          }

          // Check if repository has GitHub Pages enabled
          async function hasGitHubPages(repoName) {
            try {
              const pages = await githubApiRequest(`/repos/${userName}/${repoName}/pages`);
              return pages && pages.status;
            } catch (error) {
              if (error.statusCode === 404) {
                return false;
              }
              if (error.statusCode === 403) {
                console.log(` Rate limited on ${repoName}, waiting...`);
                await delay(2000);
                try {
                  const pages = await githubApiRequest(`/repos/${userName}/${repoName}/pages`);
                  return pages && pages.status;
                } catch (retryError) {
                  console.log(` Retry failed for ${repoName}, skipping for safety`);
                  return false;
                }
              }
              console.log(` Error checking Pages for ${repoName} (${error.statusCode || 'unknown'}): ${error.message}. Skipping for safety.`);
              return false;
            }
          }

          // Main update function
          async function updateRepoStatuses() {
            const allRepos = await discoverRepositories();

            let existingRepos = {};
            let existingReposList = [];
            try {
              existingReposList = JSON.parse(fs.readFileSync('repos.json', 'utf8'));
              existingReposList.forEach(repo => {
                existingRepos[repo.name] = repo;
              });
            } catch (error) {
              console.log('No existing repos.json found, starting fresh.');
            }

            const reposData = [];
            const changeLog = {
              added: [],
              deleted: [],
              statusChanged: [],
              dateUpdated: [],
              errors: []
            };

            console.log('\nChecking repositories for GitHub Pages...');

            for (let i = 0; i < allRepos.length; i++) {
              const repo = allRepos[i];
              console.log(`[${i + 1}/${allRepos.length}] Checking ${repo.name}...`);

              const pagesEnabled = await hasGitHubPages(repo.name);
              await delay(200);

              if (!pagesEnabled) {
                console.log(` No GitHub Pages enabled, skipping.`);
                continue;
              }

              console.log(` GitHub Pages enabled!`);

              const url = `https://${userName}.github.io/${repo.name}/`;
              const existingRepo = existingRepos[repo.name];

              if (existingRepo) {
                const status = await checkUrl(url);
                console.log(` Status: ${status}`);

                if (existingRepo.status !== status) {
                  changeLog.statusChanged.push({
                    name: repo.name,
                    url: url,
                    oldStatus: existingRepo.status,
                    newStatus: status,
                    date: existingRepo.date
                  });

                  if (status === '404' || status === 'building') {
                    changeLog.errors.push({
                      name: repo.name,
                      url: url,
                      status: status,
                      date: existingRepo.date
                    });
                  }
                }

                let repoDate = existingRepo.date;
                if (status === 'active' && existingRepo.status !== 'active') {
                  repoDate = new Date().toISOString().split('T')[0];
                  changeLog.dateUpdated.push({
                    name: repo.name,
                    url: url,
                    oldDate: existingRepo.date,
                    newDate: repoDate,
                    status: status
                  });
                  console.log(` Date updated!`);
                }

                reposData.push({
                  name: repo.name,
                  url: url,
                  date: repoDate,
                  status: status
                });

                delete existingRepos[repo.name];
              } else {
                const status = await checkUrl(url);
                console.log(` NEW repository! Status: ${status}`);

                const newDate = new Date().toISOString().split('T')[0];

                changeLog.added.push({
                  name: repo.name,
                  url: url,
                  status: status,
                  date: newDate
                });

                reposData.push({
                  name: repo.name,
                  url: url,
                  date: newDate,
                  status: status
                });
              }

              await delay(200);
            }

            for (const repoName in existingRepos) {
              const repo = existingRepos[repoName];
              changeLog.deleted.push({
                name: repo.name,
                url: repo.url,
                status: repo.status,
                date: repo.date
              });
            }

            console.log(`\nDiscovery complete!`);
            console.log(`Total repositories with GitHub Pages: ${reposData.length}`);
            console.log(`New repositories discovered: ${changeLog.added.length}`);
            console.log(`Repositories removed: ${changeLog.deleted.length}`);
            console.log(`Status changes: ${changeLog.statusChanged.length}`);

            reposData.sort((a, b) => b.date.localeCompare(a.date));

            fs.writeFileSync('repos.json', JSON.stringify(reposData, null, 2));
            console.log('repos.json updated successfully.');

            return {
              success: true,
              reposCount: reposData.length,
              changeLog: changeLog,
              hasChanges: changeLog.added.length > 0 || changeLog.deleted.length > 0 ||
                changeLog.statusChanged.length > 0 || changeLog.dateUpdated.length > 0
            };
          }

          updateRepoStatuses().then(result => {
            console.log(`\nWorkflow completed successfully!`);
            console.log(`Result: ${JSON.stringify(result)}`);
            process.exit(0);
          }).catch(error => {
            console.error('Fatal error updating repository statuses:', error);
            console.error('The workflow failed, but repos.json should still be in a valid state.');
            process.exit(1);
          });
          EOF

      - name: Commit and push if changed
        run: |
          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'
          git add repos.json
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "Auto-update repository status [skip ci]"
            git push
            echo "Changes committed and pushed"
          fi