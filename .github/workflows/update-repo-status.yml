name: Update Repository Status
on:
  schedule:
    - cron: '0 0 * * *'  # Runs every day at 00:00 UTC
  workflow_dispatch: # Allow manual trigger

permissions:
  contents: write

jobs:
  update-status:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Discover and update repositories
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_RUN_NUMBER: ${{ github.run_number }}
        run: |
          node << 'EOF'
          const fs = require('fs');
          const https = require('https');

          // Configuration
          const userName = 'anacondy';

          // Format date as dd MMM, yyyy
          function formatDate(dateString) {
            const date = new Date(dateString);
            const day = date.getDate();
            const suffix = (day === 1 || day === 21 || day === 31) ? 'st' :
                          (day === 2 || day === 22) ? 'nd' :
                          (day === 3 || day === 23) ? 'rd' : 'th';
            const monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
            const month = monthNames[date.getMonth()];
            const year = date.getFullYear();
            return `${day}${suffix} ${month}, ${year}`;
          }

          // Calculate date gap
          function calculateDateGap(creationDate, additionDate) {
            const creation = new Date(creationDate);
            const addition = new Date(additionDate);
            const gap = Math.floor((addition - creation) / (1000 * 60 * 60 * 24));
            return `${gap} days`;
          }

          // Function to make GitHub API requests
          function githubApiRequest(path, method = 'GET', body = null) {
            return new Promise((resolve, reject) => {
              const options = {
                hostname: 'api.github.com',
                path: path,
                method: method,
                headers: {
                  'User-Agent': 'RepoStatusChecker/1.0',
                  'Accept': 'application/vnd.github+json',
                  'Authorization': `Bearer ${process.env.GITHUB_TOKEN}`,
                  'X-GitHub-Api-Version': '2022-11-28'
                }
              };

              const req = https.request(options, (res) => {
                let data = '';

                res.on('data', (chunk) => {
                  data += chunk;
                });

                res.on('end', () => {
                  if (res.statusCode >= 200 && res.statusCode < 300) {
                    try {
                      resolve(JSON.parse(data));
                    } catch (parseError) {
                      reject(new Error(`Failed to parse JSON response: ${parseError.message}`));
                    }
                  } else {
                    const error = new Error(`GitHub API returned status ${res.statusCode}`);
                    error.statusCode = res.statusCode;
                    error.responseData = data.length > 200 ? data.substring(0, 200) + '...' : data;
                    reject(error);
                  }
                });
              });

              req.on('error', (error) => {
                reject(error);
              });

              if (body) {
                req.write(body);
              }

              req.end();
            });
          }

          // Function to check if URL is accessible
          function checkUrl(url) {
            return new Promise((resolve) => {
              const options = {
                method: 'HEAD',
                timeout: 10000,
                headers: {
                  'User-Agent': 'Mozilla/5.0 (compatible; RepoStatusChecker/1.0)'
                }
              };

              const req = https.request(url, options, (res) => {
                if (res.statusCode === 200) {
                  resolve('active');
                } else if (res.statusCode === 404) {
                  resolve('404');
                } else {
                  resolve('building');
                }
              });

              req.on('error', () => {
                resolve('404');
              });

              req.on('timeout', () => {
                req.destroy();
                resolve('building');
              });

              req.end();
            });
          }

          // Function to delay between requests
          function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
          }

          // Fetch all public repositories from the user
          async function discoverRepositories() {
            console.log('Discovering repositories from GitHub...');
            const allRepos = [];
            let page = 1;
            const maxPages = 50;

            while (page <= maxPages) {
              try {
                const repos = await githubApiRequest(`/users/${userName}/repos?type=public&per_page=100&page=${page}`);

                if (!repos || repos.length === 0) break;

                allRepos.push(...repos);
                console.log(`Fetched page ${page}: ${repos.length} repositories`);

                if (repos.length < 100) break;
                page++;
                await delay(200);
              } catch (error) {
                console.error(`Error fetching repositories on page ${page}:`, error.message);
                break;
              }
            }

            console.log(`Total repositories found: ${allRepos.length}`);
            return allRepos;
          }

          // Check if repository has GitHub Pages enabled
          async function hasGitHubPages(repoName) {
            try {
              const pages = await githubApiRequest(`/repos/${userName}/${repoName}/pages`);
              return pages && pages.status;
            } catch (error) {
              if (error.statusCode === 404) {
                return false;
              }
              if (error.statusCode === 403) {
                console.log(` Rate limited on ${repoName}, waiting...`);
                await delay(2000);
                try {
                  const pages = await githubApiRequest(`/repos/${userName}/${repoName}/pages`);
                  return pages && pages.status;
                } catch (retryError) {
                  console.log(` Retry failed for ${repoName}, skipping for safety`);
                  return false;
                }
              }
              console.log(` Error checking Pages for ${repoName} (${error.statusCode || 'unknown'}): ${error.message}. Skipping for safety.`);
              return false;
            }
          }

          // Main update function
          async function updateRepoStatuses() {
            const allRepos = await discoverRepositories();

            let existingRepos = {};
            let existingReposList = [];
            try {
              existingReposList = JSON.parse(fs.readFileSync('repos.json', 'utf8'));
              existingReposList.forEach(repo => {
                existingRepos[repo.name] = repo;
              });
            } catch (error) {
              console.log('No existing repos.json found, starting fresh.');
            }

            const reposData = [];
            const changeLog = {
              added: [],
              deleted: [],
              statusChanged: [],
              dateUpdated: [],
              errors: []
            };

            console.log('\nChecking repositories for GitHub Pages...');

            const workflowVersion = process.env.GITHUB_RUN_NUMBER || 'Unknown';
            const previousReposCount = existingReposList.length;

            for (let i = 0; i < allRepos.length; i++) {
              const repo = allRepos[i];
              console.log(`[${i + 1}/${allRepos.length}] Checking ${repo.name}...`);

              const pagesEnabled = await hasGitHubPages(repo.name);
              await delay(200);

              if (!pagesEnabled) {
                console.log(` No GitHub Pages enabled, skipping.`);
                continue;
              }

              console.log(` GitHub Pages enabled!`);

              const url = `https://${userName}.github.io/${repo.name}/`;
              const existingRepo = existingRepos[repo.name];

              const status = await checkUrl(url);
              console.log(` Status: ${status}`);

              if (existingRepo) {
                if (existingRepo.status !== status) {
                  changeLog.statusChanged.push({
                    name: repo.name,
                    url: url,
                    oldStatus: existingRepo.status,
                    newStatus: status,
                    date: existingRepo.date
                  });

                  if (status === '404' || status === 'building') {
                    changeLog.errors.push({
                      name: repo.name,
                      url: url,
                      status: status,
                      date: existingRepo.date
                    });
                  }
                }

                let repoDate = existingRepo.date;
                if (status === 'active' && existingRepo.status !== 'active') {
                  repoDate = new Date().toISOString().split('T')[0];
                  changeLog.dateUpdated.push({
                    name: repo.name,
                    url: url,
                    oldDate: existingRepo.date,
                    newDate: repoDate,
                    status: status
                  });
                  console.log(` Date updated!`);
                }

                reposData.push({
                  name: repo.name,
                  url: url,
                  date: repoDate,
                  status: status,
                  workflow_version: workflowVersion
                });

                delete existingRepos[repo.name];
              } else {
                const newDate = new Date().toISOString().split('T')[0];

                changeLog.added.push({
                  name: repo.name,
                  url: url,
                  status: status,
                  date: newDate
                });

                reposData.push({
                  name: repo.name,
                  url: url,
                  date: newDate,
                  status: status,
                  workflow_version: workflowVersion
                });
              }

              await delay(200);
            }

            for (const repoName in existingRepos) {
              const repo = existingRepos[repoName];
              changeLog.deleted.push({
                name: repo.name,
                url: repo.url,
                status: repo.status,
                date: repo.date
              });
            }

            // Fetch creation date and calculate date gap for each repository
            for (const repo of reposData) {
              try {
                const repoInfo = await githubApiRequest(`/repos/${userName}/${repo.name}`);
                repo.created_at = repoInfo.created_at.split('T')[0];
                repo.date_gap = calculateDateGap(repo.created_at, repo.date);
              } catch (error) {
                console.error(`Failed to fetch creation date for ${repo.name}:`, error.message);
                repo.created_at = 'Unknown';
                repo.date_gap = 'Unknown';
              }
            }

            console.log(`\nDiscovery complete!`);
            console.log(`Workflow #${workflowVersion} (${formatDate(new Date().toISOString())})`);
            console.log(`Previous version (${formatDate(existingReposList[0]?.date || new Date().toISOString())}): ${previousReposCount} repositories`);
            console.log(`New version (${formatDate(new Date().toISOString())}): ${reposData.length} repositories`);
            console.log(`Additions: ${changeLog.added.length} repositories`);
            console.log(`Deletions: ${changeLog.deleted.length} repositories`);

            reposData.sort((a, b) => new Date(b.date) - new Date(a.date));

            fs.writeFileSync('repos.json', JSON.stringify(reposData, null, 2));
            console.log('repos.json updated successfully.');

            // Generate wiki content
            let wikiContent = `# Repository Status and History\n\n`;
            wikiContent += `## Workflow #${workflowVersion} (${formatDate(new Date().toISOString())})\n`;
            wikiContent += `- Previous version (${formatDate(existingReposList[0]?.date || new Date().toISOString())}): ${previousReposCount} repositories\n`;
            wikiContent += `- New version (${formatDate(new Date().toISOString())}): ${reposData.length} repositories\n`;
            wikiContent += `- Additions: ${changeLog.added.length} repositories\n`;
            wikiContent += `- Deletions: ${changeLog.deleted.length} repositories\n\n`;

            wikiContent += `| Repository Name       | Link                                  | Added Date       | Creation Date   | Date Gap       | Status       | Workflow Version |\n`;
            wikiContent += `|-----------------------|---------------------------------------|------------------|------------------|----------------|---------------|------------------|\n`;

            reposData.forEach(repo => {
              wikiContent += `| ${repo.name} | [Link](${repo.url}) | ${formatDate(repo.date)} | ${formatDate(repo.created_at)} | ${repo.date_gap} | ${repo.status} | #${repo.workflow_version} |\n`;
            });

            // Save wiki content to a file
            fs.writeFileSync('Repository-Status-and-History.md', wikiContent);
            console.log('Repository-Status-and-History.md generated successfully.');

            return {
              success: true,
              reposCount: reposData.length,
              changeLog: changeLog,
              hasChanges: changeLog.added.length > 0 || changeLog.deleted.length > 0 ||
                changeLog.statusChanged.length > 0 || changeLog.dateUpdated.length > 0,
              workflowVersion: workflowVersion
            };
          }

          updateRepoStatuses().then((result) => {
            console.log(`\nWorkflow completed successfully!`);
            process.exit(0);
          }).catch(error => {
            console.error('Fatal error updating repository statuses:', error);
            console.error('The workflow failed, but repos.json should still be in a valid state.');
            process.exit(1);
          });
          EOF

      - name: Commit and push if changed
        run: |
          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'
          git add repos.json
          git add Repository-Status-and-History.md
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "Auto-update repository status and wiki page [skip ci]"
            git push
            echo "Changes committed and pushed"
          fi

      - name: Push to Wiki
        run: |
          cd ..
          git clone https://${{ secrets.GITHUB_TOKEN }}@github.com/anacondy/3-DVD-archieve.wiki.git
          cd 3-DVD-archieve.wiki
          cp ../3-DVD-archieve/Repository-Status-and-History.md .
          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'
          git add Repository-Status-and-History.md
          git commit -m "Auto-update wiki page [skip ci]"
          git push